{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dbdaora Communicates with NoSQL (and SQL for future) databases using repository and service patterns and python dataclasses Documentation : https://dutradda.github.io/dbdaora/ Source Code : https://github.com/dutradda/dbdaora Key Features Creates an optional service layer with cache and circuit breaker Supports for redis data types: Hash Sorted Set (Others data types are planned) Backup redis data into other databases: Google Datastore Mongodb (soon) SQL databases with SQLAlchemy (soon) (Others data bases are planned) Support for other databases are in development. Requirements Python 3.8+ jsondaora for data validation/parsing circuitbreaker cachetools Optionals: aioredis google-cloud-datastore Instalation $ pip install dbdaora Simple redis hash example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_cls = Person key_attrs = ( 'id' ,) repository = PersonRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( repository . add ( person )) geted_person = asyncio . run ( repository . query ( person . id ) . entity ) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 Simple redis sorted set example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , SortedSetEntity , SortedSetRepository , ) @dataclass class Playlist ( SortedSetEntity ): id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist key_attrs = ( 'id' ,) repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) values = [( 'm1' , 1 ), ( 'm2' , 2 ), ( 'm3' , 3 )] playlist = Playlist ( id = 'my_plalist' , values = values ) asyncio . run ( repository . add ( playlist )) geted_playlist = asyncio . run ( repository . query ( playlist . id ) . entity ) print ( geted_playlist ) Playlist ( values = [ 'm1' , 'm2' , 'm3' ], id = 'my_plalist' Using the service layer The service layer uses the backup dataset when redis is offline, opening a circuit breaker. It has an optional cache system too. import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , make_hash_service , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_name = 'person' entity_cls = Person key_attrs = ( 'id' ,) async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( service . add ( person )) geted_person = asyncio . run ( service . get_one ( person . id )) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"dbdaora"},{"location":"#dbdaora","text":"Communicates with NoSQL (and SQL for future) databases using repository and service patterns and python dataclasses Documentation : https://dutradda.github.io/dbdaora/ Source Code : https://github.com/dutradda/dbdaora","title":"dbdaora"},{"location":"#key-features","text":"Creates an optional service layer with cache and circuit breaker Supports for redis data types: Hash Sorted Set (Others data types are planned) Backup redis data into other databases: Google Datastore Mongodb (soon) SQL databases with SQLAlchemy (soon) (Others data bases are planned) Support for other databases are in development.","title":"Key Features"},{"location":"#requirements","text":"Python 3.8+ jsondaora for data validation/parsing circuitbreaker cachetools Optionals: aioredis google-cloud-datastore","title":"Requirements"},{"location":"#instalation","text":"$ pip install dbdaora","title":"Instalation"},{"location":"#simple-redis-hash-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_cls = Person key_attrs = ( 'id' ,) repository = PersonRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( repository . add ( person )) geted_person = asyncio . run ( repository . query ( person . id ) . entity ) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"Simple redis hash example"},{"location":"#simple-redis-sorted-set-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , SortedSetEntity , SortedSetRepository , ) @dataclass class Playlist ( SortedSetEntity ): id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist key_attrs = ( 'id' ,) repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) values = [( 'm1' , 1 ), ( 'm2' , 2 ), ( 'm3' , 3 )] playlist = Playlist ( id = 'my_plalist' , values = values ) asyncio . run ( repository . add ( playlist )) geted_playlist = asyncio . run ( repository . query ( playlist . id ) . entity ) print ( geted_playlist ) Playlist ( values = [ 'm1' , 'm2' , 'm3' ], id = 'my_plalist'","title":"Simple redis sorted set example"},{"location":"#using-the-service-layer","text":"The service layer uses the backup dataset when redis is offline, opening a circuit breaker. It has an optional cache system too. import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , make_hash_service , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_name = 'person' entity_cls = Person key_attrs = ( 'id' ,) async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( service . add ( person )) geted_person = asyncio . run ( service . get_one ( person . id )) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"Using the service layer"},{"location":"changelog/","text":"CHANGELOG 0.4.0 - 2020-04-25 Improve repositories interface Add support for TypedDict Improve sorted set entity Improve coverage 0.3.0 - 2020-04-25 Create new tests and fix some bugs Add subclass validation for MemoryRepository 0.2.1 - 2020-04-25 Fix DatastoreDataSource.make_key method 0.2.0 - 2020-04-24 Create dbdaora package","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"CHANGELOG"},{"location":"changelog/#040-2020-04-25","text":"Improve repositories interface Add support for TypedDict Improve sorted set entity Improve coverage","title":"0.4.0 - 2020-04-25"},{"location":"changelog/#030-2020-04-25","text":"Create new tests and fix some bugs Add subclass validation for MemoryRepository","title":"0.3.0 - 2020-04-25"},{"location":"changelog/#021-2020-04-25","text":"Fix DatastoreDataSource.make_key method","title":"0.2.1 - 2020-04-25"},{"location":"changelog/#020-2020-04-24","text":"Create dbdaora package","title":"0.2.0 - 2020-04-24"},{"location":"contributing/","text":"Starting Development git clone git@github.com:dutradda/dbdaora.git --recursive cd dbdaora make setup-python-virtualenv source venv/bin/activate make setup-python-project bake setup-dbdaora bake dependencies Running the integration suite: bake integration Other bake tasks: bake check-code bake tests-docs bake serve-docs bake add-changelog m = \"Add my cool feature\" You can run bake to see all tasks available.","title":"Development - Contributing"},{"location":"contributing/#starting-development","text":"git clone git@github.com:dutradda/dbdaora.git --recursive cd dbdaora make setup-python-virtualenv source venv/bin/activate make setup-python-project bake setup-dbdaora bake dependencies","title":"Starting Development"},{"location":"contributing/#running-the-integration-suite","text":"bake integration","title":"Running the integration suite:"},{"location":"contributing/#other-bake-tasks","text":"bake check-code bake tests-docs bake serve-docs bake add-changelog m = \"Add my cool feature\" You can run bake to see all tasks available.","title":"Other bake tasks:"},{"location":"typed-dict/","text":"Typed Dict Example import asyncio from typing import TypedDict from jsondaora import jsondaora from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetDictEntity , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @jsondaora class Person ( TypedDict ): id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( id = name . replace ( ' ' , '_' ) . lower (), name = name , age = age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): key_attrs = ( 'id' ,) person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @jsondaora class Playlist ( SortedSetDictEntity ): person_id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist key_attrs = ( 'person_id' ,) playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person [ 'id' ], 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person [ 'id' ]) goted_playlist = await playlist_repository . query ( goted_person [ 'id' ]) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) { 'id' : 'john_doe' , 'name' : 'John Doe' , 'age' : 33 } { 'values' : [ 'm1' , 'm2' , 'm3' ], 'person_id' : 'john_doe'","title":"Typed Dict Entity"},{"location":"typed-dict/#typed-dict-example","text":"import asyncio from typing import TypedDict from jsondaora import jsondaora from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetDictEntity , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @jsondaora class Person ( TypedDict ): id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( id = name . replace ( ' ' , '_' ) . lower (), name = name , age = age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): key_attrs = ( 'id' ,) person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @jsondaora class Playlist ( SortedSetDictEntity ): person_id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist key_attrs = ( 'person_id' ,) playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person [ 'id' ], 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person [ 'id' ]) goted_playlist = await playlist_repository . query ( goted_person [ 'id' ]) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) { 'id' : 'john_doe' , 'name' : 'John Doe' , 'age' : 33 } { 'values' : [ 'm1' , 'm2' , 'm3' ], 'person_id' : 'john_doe'","title":"Typed Dict Example"},{"location":"domain-model/simple/","text":"Simple Domain Model Example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetEntity , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_name = 'person' entity_cls = Person key_attrs = ( 'id' ,) person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @dataclass class PlayList ( SortedSetEntity ): person_id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_name = 'playlist' key_attrs = ( 'person_id' ,) entity_cls = PlayList entity_id_name = 'person_id' playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> PlayList : return PlayList ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person . id , 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person . id ) goted_playlist = await playlist_repository . query ( goted_person . id ) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 ) PlayList ( values = [ 'm1' , 'm2' , 'm3' ], person_id = 'john_doe'","title":"Domain Model Example"},{"location":"domain-model/simple/#simple-domain-model-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetEntity , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_name = 'person' entity_cls = Person key_attrs = ( 'id' ,) person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @dataclass class PlayList ( SortedSetEntity ): person_id : str class PlaylistRepository ( SortedSetRepository [ str ]): entity_name = 'playlist' key_attrs = ( 'person_id' ,) entity_cls = PlayList entity_id_name = 'person_id' playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> PlayList : return PlayList ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person . id , 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person . id ) goted_playlist = await playlist_repository . query ( goted_person . id ) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 ) PlayList ( values = [ 'm1' , 'm2' , 'm3' ], person_id = 'john_doe'","title":"Simple Domain Model Example"}]}