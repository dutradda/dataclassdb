{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dbdaora Communicates with NoSQL (and SQL for future) databases using repository and service patterns and python dataclasses Documentation : https://dutradda.github.io/dbdaora/ Source Code : https://github.com/dutradda/dbdaora Key Features Creates an optional service layer with cache and circuit breaker Supports for redis data types: Hash Sorted Set (Others data types are planned) Backup redis data into other databases: Google Datastore Mongodb (soon) SQL databases with SQLAlchemy (soon) (Others data bases are planned) Support for other databases are in development. Requirements Python 3.8+ jsondaora for data validation/parsing circuitbreaker cachetools Optionals: aioredis google-cloud-datastore Instalation $ pip install dbdaora Simple redis hash example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_cls = Person key_attrs = ( 'id' ,) repository = PersonRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( repository . add ( person )) geted_person = asyncio . run ( repository . query ( person . id ) . entity ) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 Simple redis sorted set example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , SortedSetData , SortedSetRepository , ) @dataclass class Playlist : id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) values = [( 'm1' , 1 ), ( 'm2' , 2 ), ( 'm3' , 3 )] playlist = Playlist ( id = 'my_plalist' , values = values ) asyncio . run ( repository . add ( playlist )) geted_playlist = asyncio . run ( repository . query ( playlist . id ) . entity ) print ( geted_playlist ) Playlist ( id = 'my_plalist' , values = [ 'm1' , 'm2' , 'm3' ] Using the service layer The service layer uses the backup dataset when redis is offline, opening a circuit breaker. It has an optional cache system too. import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , make_hash_service , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( service . add ( person )) geted_person = asyncio . run ( service . get_one ( person . id )) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"dbdaora"},{"location":"#dbdaora","text":"Communicates with NoSQL (and SQL for future) databases using repository and service patterns and python dataclasses Documentation : https://dutradda.github.io/dbdaora/ Source Code : https://github.com/dutradda/dbdaora","title":"dbdaora"},{"location":"#key-features","text":"Creates an optional service layer with cache and circuit breaker Supports for redis data types: Hash Sorted Set (Others data types are planned) Backup redis data into other databases: Google Datastore Mongodb (soon) SQL databases with SQLAlchemy (soon) (Others data bases are planned) Support for other databases are in development.","title":"Key Features"},{"location":"#requirements","text":"Python 3.8+ jsondaora for data validation/parsing circuitbreaker cachetools Optionals: aioredis google-cloud-datastore","title":"Requirements"},{"location":"#instalation","text":"$ pip install dbdaora","title":"Instalation"},{"location":"#simple-redis-hash-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ]): entity_cls = Person key_attrs = ( 'id' ,) repository = PersonRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( repository . add ( person )) geted_person = asyncio . run ( repository . query ( person . id ) . entity ) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"Simple redis hash example"},{"location":"#simple-redis-sorted-set-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , SortedSetData , SortedSetRepository , ) @dataclass class Playlist : id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) values = [( 'm1' , 1 ), ( 'm2' , 2 ), ( 'm3' , 3 )] playlist = Playlist ( id = 'my_plalist' , values = values ) asyncio . run ( repository . add ( playlist )) geted_playlist = asyncio . run ( repository . query ( playlist . id ) . entity ) print ( geted_playlist ) Playlist ( id = 'my_plalist' , values = [ 'm1' , 'm2' , 'm3' ]","title":"Simple redis sorted set example"},{"location":"#using-the-service-layer","text":"The service layer uses the backup dataset when redis is offline, opening a circuit breaker. It has an optional cache system too. import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , make_hash_service , ) @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) person = make_person ( 'John Doe' , 33 ) asyncio . run ( service . add ( person )) geted_person = asyncio . run ( service . get_one ( person . id )) print ( geted_person ) Person ( id = 'john_doe' , name = 'John Doe' , age = 33","title":"Using the service layer"},{"location":"changelog/","text":"CHANGELOG 0.19.1 - 2020-08-13 Improve georadius support 0.19.0 - 2020-08-12 Add fallback circuit breaker for service 0.18.0 - 2020-07-23 Add support for redis geospatial data type Fix Hash services conditional imports Fix Service class to be generic 0.17.2 - 2020-07-21 Fix service 0.17.1 - 2020-07-21 Fix service 0.16.0 - 2020-07-21 Improve Services 0.15.1 - 2020-07-09 Improve type hints 0.15.0 - 2020-06-25 Create exists method service and repository 0.14.0 - 2020-06-18 Create mongodb fallback data source 0.13.2 - 2020-06-16 Fix base service 0.13.1 - 2020-06-16 Fix service 0.13.0 - 2020-06-14 Improve delete method of base repository 0.12.0 - 2020-06-14 Improve service cache 0.11.0 - 2020-06-12 Improve boolean repository 0.10.1 - 2020-05-29 Improve DaoraCache 0.10.0 - 2020-05-27 Create BooleanReposity and service 0.9.6 - 2020-05-26 Remove experimental sync repository 0.9.5 - 2020-05-22 Adding sync repository. Experimental feature (WIP) 0.9.4 - 2020-05-15 Remove redis transaction from hash repository Fix hash service add method 0.9.3 - 2020-05-15 Improve ttldaora cache 0.9.2 - 2020-05-13 Improve service add method 0.9.1 - 2020-05-12 Add ttl daora cache to service builder 0.9.0 - 2020-05-12 Create simple ttl cache class 0.8.0 - 2020-05-08 Improve add entity on repositories 0.7.1 - 2020-05-08 Fix requires 0.7.0 - 2020-05-07 Improve hash service cache 0.6.2 - 2020-05-05 Fix sorted set fallback key Fix hash service cache 0.6.1 - 2020-05-04 Fix repository task_done_callback 0.6.0 - 2020-05-02 Simplify get_many 0.5.2 - 2020-04-30 Improve hash fallback data 0.5.1 - 2020-04-28 Fix get_many from fallback 0.5.0 - 2020-04-26 Improve repositories interface Create tests for datastore repositories 0.4.1 - 2020-04-25 Improve datastore repositories 0.4.0 - 2020-04-25 Improve repositories interface Add support for TypedDict Improve sorted set entity Improve coverage 0.3.0 - 2020-04-25 Create new tests and fix some bugs Add subclass validation for MemoryRepository 0.2.1 - 2020-04-25 Fix DatastoreDataSource.make_key method 0.2.0 - 2020-04-24 Create dbdaora package","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"CHANGELOG"},{"location":"changelog/#0191-2020-08-13","text":"Improve georadius support","title":"0.19.1 - 2020-08-13"},{"location":"changelog/#0190-2020-08-12","text":"Add fallback circuit breaker for service","title":"0.19.0 - 2020-08-12"},{"location":"changelog/#0180-2020-07-23","text":"Add support for redis geospatial data type Fix Hash services conditional imports Fix Service class to be generic","title":"0.18.0 - 2020-07-23"},{"location":"changelog/#0172-2020-07-21","text":"Fix service","title":"0.17.2 - 2020-07-21"},{"location":"changelog/#0171-2020-07-21","text":"Fix service","title":"0.17.1 - 2020-07-21"},{"location":"changelog/#0160-2020-07-21","text":"Improve Services","title":"0.16.0 - 2020-07-21"},{"location":"changelog/#0151-2020-07-09","text":"Improve type hints","title":"0.15.1 - 2020-07-09"},{"location":"changelog/#0150-2020-06-25","text":"Create exists method service and repository","title":"0.15.0 - 2020-06-25"},{"location":"changelog/#0140-2020-06-18","text":"Create mongodb fallback data source","title":"0.14.0 - 2020-06-18"},{"location":"changelog/#0132-2020-06-16","text":"Fix base service","title":"0.13.2 - 2020-06-16"},{"location":"changelog/#0131-2020-06-16","text":"Fix service","title":"0.13.1 - 2020-06-16"},{"location":"changelog/#0130-2020-06-14","text":"Improve delete method of base repository","title":"0.13.0 - 2020-06-14"},{"location":"changelog/#0120-2020-06-14","text":"Improve service cache","title":"0.12.0 - 2020-06-14"},{"location":"changelog/#0110-2020-06-12","text":"Improve boolean repository","title":"0.11.0 - 2020-06-12"},{"location":"changelog/#0101-2020-05-29","text":"Improve DaoraCache","title":"0.10.1 - 2020-05-29"},{"location":"changelog/#0100-2020-05-27","text":"Create BooleanReposity and service","title":"0.10.0 - 2020-05-27"},{"location":"changelog/#096-2020-05-26","text":"Remove experimental sync repository","title":"0.9.6 - 2020-05-26"},{"location":"changelog/#095-2020-05-22","text":"Adding sync repository. Experimental feature (WIP)","title":"0.9.5 - 2020-05-22"},{"location":"changelog/#094-2020-05-15","text":"Remove redis transaction from hash repository Fix hash service add method","title":"0.9.4 - 2020-05-15"},{"location":"changelog/#093-2020-05-15","text":"Improve ttldaora cache","title":"0.9.3 - 2020-05-15"},{"location":"changelog/#092-2020-05-13","text":"Improve service add method","title":"0.9.2 - 2020-05-13"},{"location":"changelog/#091-2020-05-12","text":"Add ttl daora cache to service builder","title":"0.9.1 - 2020-05-12"},{"location":"changelog/#090-2020-05-12","text":"Create simple ttl cache class","title":"0.9.0 - 2020-05-12"},{"location":"changelog/#080-2020-05-08","text":"Improve add entity on repositories","title":"0.8.0 - 2020-05-08"},{"location":"changelog/#071-2020-05-08","text":"Fix requires","title":"0.7.1 - 2020-05-08"},{"location":"changelog/#070-2020-05-07","text":"Improve hash service cache","title":"0.7.0 - 2020-05-07"},{"location":"changelog/#062-2020-05-05","text":"Fix sorted set fallback key Fix hash service cache","title":"0.6.2 - 2020-05-05"},{"location":"changelog/#061-2020-05-04","text":"Fix repository task_done_callback","title":"0.6.1 - 2020-05-04"},{"location":"changelog/#060-2020-05-02","text":"Simplify get_many","title":"0.6.0 - 2020-05-02"},{"location":"changelog/#052-2020-04-30","text":"Improve hash fallback data","title":"0.5.2 - 2020-04-30"},{"location":"changelog/#051-2020-04-28","text":"Fix get_many from fallback","title":"0.5.1 - 2020-04-28"},{"location":"changelog/#050-2020-04-26","text":"Improve repositories interface Create tests for datastore repositories","title":"0.5.0 - 2020-04-26"},{"location":"changelog/#041-2020-04-25","text":"Improve datastore repositories","title":"0.4.1 - 2020-04-25"},{"location":"changelog/#040-2020-04-25","text":"Improve repositories interface Add support for TypedDict Improve sorted set entity Improve coverage","title":"0.4.0 - 2020-04-25"},{"location":"changelog/#030-2020-04-25","text":"Create new tests and fix some bugs Add subclass validation for MemoryRepository","title":"0.3.0 - 2020-04-25"},{"location":"changelog/#021-2020-04-25","text":"Fix DatastoreDataSource.make_key method","title":"0.2.1 - 2020-04-25"},{"location":"changelog/#020-2020-04-24","text":"Create dbdaora package","title":"0.2.0 - 2020-04-24"},{"location":"contributing/","text":"Starting Development git clone git@github.com:dutradda/dbdaora.git --recursive cd dbdaora make setup-python-virtualenv source venv/bin/activate make setup-python-project bake setup-dbdaora bake dependencies Running the integration suite: bake integration Other bake tasks: bake check-code bake tests-docs bake serve-docs bake add-changelog m = \"Add my cool feature\" You can run bake to see all tasks available.","title":"Development - Contributing"},{"location":"contributing/#starting-development","text":"git clone git@github.com:dutradda/dbdaora.git --recursive cd dbdaora make setup-python-virtualenv source venv/bin/activate make setup-python-project bake setup-dbdaora bake dependencies","title":"Starting Development"},{"location":"contributing/#running-the-integration-suite","text":"bake integration","title":"Running the integration suite:"},{"location":"contributing/#other-bake-tasks","text":"bake check-code bake tests-docs bake serve-docs bake add-changelog m = \"Add my cool feature\" You can run bake to see all tasks available.","title":"Other bake tasks:"},{"location":"typed-dict/","text":"Typed Dict Example import asyncio from typing import TypedDict from jsondaora import jsondaora from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetData , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @jsondaora class Person ( TypedDict ): id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( id = name . replace ( ' ' , '_' ) . lower (), name = name , age = age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @jsondaora class Playlist ( TypedDict ): person_id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist id_name = 'person_id' playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person [ 'id' ], 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person [ 'id' ]) goted_playlist = await playlist_repository . query ( goted_person [ 'id' ]) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) { 'id' : 'john_doe' , 'name' : 'John Doe' , 'age' : 33 } { 'values' : [ 'm1' , 'm2' , 'm3' ], 'person_id' : 'john_doe'","title":"Typed Dict Entity"},{"location":"typed-dict/#typed-dict-example","text":"import asyncio from typing import TypedDict from jsondaora import jsondaora from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetData , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @jsondaora class Person ( TypedDict ): id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( id = name . replace ( ' ' , '_' ) . lower (), name = name , age = age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @jsondaora class Playlist ( TypedDict ): person_id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ]): entity_cls = Playlist id_name = 'person_id' playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person [ 'id' ], 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person [ 'id' ]) goted_playlist = await playlist_repository . query ( goted_person [ 'id' ]) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) { 'id' : 'john_doe' , 'name' : 'John Doe' , 'age' : 33 } { 'values' : [ 'm1' , 'm2' , 'm3' ], 'person_id' : 'john_doe'","title":"Typed Dict Example"},{"location":"domain-model/simple/","text":"Simple Domain Model Example import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetData , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @dataclass class Playlist : person_id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ], entity_cls = Playlist , id_name = 'person_id' ): ... playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person . id , 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person . id ) goted_playlist = await playlist_repository . query ( goted_person . id ) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 ) Playlist ( person_id = 'john_doe' , values = [ 'm1' , 'm2' , 'm3' ]","title":"Domain Model Example"},{"location":"domain-model/simple/#simple-domain-model-example","text":"import asyncio from dataclasses import dataclass from dbdaora import ( DictFallbackDataSource , DictMemoryDataSource , HashRepository , SortedSetData , SortedSetRepository , make_hash_service , ) # Data Source Layer async def make_memory_data_source () -> DictMemoryDataSource : return DictMemoryDataSource () async def make_fallback_data_source () -> DictFallbackDataSource : return DictFallbackDataSource () # Domain Layer @dataclass class Person : id : str name : str age : int def make_person ( name : str , age : int ) -> Person : return Person ( name . replace ( ' ' , '_' ) . lower (), name , age ) class PersonRepository ( HashRepository [ str ], entity_cls = Person ): ... person_service = asyncio . run ( make_hash_service ( PersonRepository , memory_data_source_factory = make_memory_data_source , fallback_data_source_factory = make_fallback_data_source , repository_expire_time = 60 , ) ) @dataclass class Playlist : person_id : str values : SortedSetData class PlaylistRepository ( SortedSetRepository [ str ], entity_cls = Playlist , id_name = 'person_id' ): ... playlist_repository = PlaylistRepository ( memory_data_source = DictMemoryDataSource (), fallback_data_source = DictFallbackDataSource (), expire_time = 60 , ) def make_playlist ( person_id : str , * musics_ids : str ) -> Playlist : return Playlist ( person_id = person_id , values = [( id_ , i ) for i , id_ in enumerate ( musics_ids )], ) # Application Layer async def main () -> None : person = make_person ( 'John Doe' , 33 ) playlist = make_playlist ( person . id , 'm1' , 'm2' , 'm3' ) await person_service . add ( person ) await playlist_repository . add ( playlist ) goted_person = await person_service . get_one ( person . id ) goted_playlist = await playlist_repository . query ( goted_person . id ) . entity print ( goted_person ) print ( goted_playlist ) asyncio . run ( main ()) Person ( id = 'john_doe' , name = 'John Doe' , age = 33 ) Playlist ( person_id = 'john_doe' , values = [ 'm1' , 'm2' , 'm3' ]","title":"Simple Domain Model Example"}]}